#!/bin/bash

# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Script to build a bootable keyfob-based chromeos system image from within
# a coreos setup. This assumes that all needed packages have been built into
# the given target's root with binary packages turned on. This script will
# build the Chrome OS image using only pre-built binary packages.

SCRIPT_ROOT=$(dirname $(readlink -f "$0"))
. "${SCRIPT_ROOT}/common.sh" || exit 1

# Script must run inside the chroot
restart_in_chroot_if_needed "$@"

assert_not_root_user

DEFAULT_GROUP=developer

# Developer-visible flags.
DEFINE_string board "${DEFAULT_BOARD}" \
  "The board to build an image for."
DEFINE_boolean enable_rootfs_verification ${FLAGS_TRUE} \
  "Default all bootloaders to use kernel-based root fs integrity checking."
DEFINE_boolean enable_verity ${FLAGS_FALSE} \
  "Default GRUB to use dm-verity-enabled boot arguments"
DEFINE_string base_pkg "coreos-base/coreos" \
  "The base portage package to base the build off of (only applies to prod images)"
DEFINE_string base_dev_pkg "coreos-base/coreos-dev" \
  "The base portage package to base the build off of (only applies to dev images)"
DEFINE_string output_root "${DEFAULT_BUILD_ROOT}/images" \
  "Directory in which to place image result directories (named by version)"
DEFINE_string disk_layout "" \
  "The disk layout type to use for this image."
DEFINE_string group "${DEFAULT_GROUP}" \
  "The update group."
DEFINE_boolean generate_update "${FLAGS_FALSE}" \
  "Generate update payload. (prod only)"
DEFINE_boolean extract_update "${FLAGS_TRUE}" \
  "Extract the /usr partition for generating updates."
DEFINE_string developer_data "" \
  "Insert a custom cloudinit file into the image."

# include upload options
. "${BUILD_LIBRARY_DIR}/release_util.sh" || exit 1

FLAGS_HELP="USAGE: build_image [flags] [list of images to build].
This script is used to build a CoreOS image. CoreOS comes in many
different forms.  This scripts can be used to build the following:

prod - Production image for CoreOS. This image is for booting.
dev - Developer image. Like base but with additional developer packages.
container - Developer image with single filesystem, bootable by nspawn.

Examples:

build_image --board=<board> dev prod - builds developer and production images.
...
"
show_help_if_requested "$@"

# The following options are advanced options, only available to those willing
# to read the source code. They are not shown in help output, since they are
# not needed for the typical developer workflow.
DEFINE_integer build_attempt 1 \
  "The build attempt for this image build."
DEFINE_integer jobs "${NUM_JOBS}" \
  "How many packages to build in parallel at maximum."
DEFINE_boolean replace ${FLAGS_FALSE} \
  "Overwrite existing output, if any."
DEFINE_string version "" \
  "Overrides version number in name to this version."

# Parse command line.
FLAGS "$@" || exit 1

eval set -- "${FLAGS_ARGV:-dev}"

# Only now can we die on error.  shflags functions leak non-zero error codes,
# so will die prematurely if 'switch_to_strict_mode' is specified before now.
switch_to_strict_mode

check_gsutil_opts

# N.B.  Ordering matters for some of the libraries below, because
# some of the files contain initialization used by later files.
. "${BUILD_LIBRARY_DIR}/toolchain_util.sh" || exit 1
. "${BUILD_LIBRARY_DIR}/board_options.sh" || exit 1
. "${BUILD_LIBRARY_DIR}/build_image_util.sh" || exit 1
. "${BUILD_LIBRARY_DIR}/prod_image_util.sh" || exit 1
. "${BUILD_LIBRARY_DIR}/dev_image_util.sh" || exit 1
. "${BUILD_LIBRARY_DIR}/test_image_content.sh" || exit 1

PROD_IMAGE=0
DEV_IMAGE=0
CONTAINER=0
for arg in "$@"; do
  case "${arg}" in
    prod) PROD_IMAGE=1 ;;
    dev)  DEV_IMAGE=1 ;;
    container) CONTAINER=1 ;;
    *)    die_notrace "Unknown image type ${arg}" ;;
  esac
done

eclean-$BOARD -d packages

# Check that the build root is sane.
if [[ ${skip_test_build_root} -ne 1 ]]; then
  info "Checking build root"
  test_image_content "${BOARD_ROOT}"
fi

# Hack to fix bug where x86_64 CHOST line gets incorrectly added.
# ToDo(msb): remove this hack.
PACKAGES_FILE="${BOARD_ROOT}/packages/Packages"
sudo sed -e "s/CHOST: x86_64-pc-linux-gnu//" -i "${PACKAGES_FILE}"

# Handle existing directory.
if [[ -e "${BUILD_DIR}" ]]; then
  if [[ ${FLAGS_replace} -eq ${FLAGS_TRUE} ]]; then
    sudo rm -rf "${BUILD_DIR}"
  else
    error "Directory ${BUILD_DIR} already exists."
    error "Use --build_attempt option to specify an unused attempt."
    error "Or use --replace if you want to overwrite this directory."
    die "Unwilling to overwrite ${BUILD_DIR}."
  fi
fi

# Create the output directory and temporary mount points.
mkdir -p "${BUILD_DIR}"

DISK_LAYOUT="${FLAGS_disk_layout:-base}"
CONTAINER_LAYOUT="${FLAGS_disk_layout:-container}"

if [[ -n "${FLAGS_developer_data}" ]]; then
  if [[ ! -f "${FLAGS_developer_data}" ]]; then
    die_notrace "Developer data is not a file: ${FLAGS_developer_data}"
  fi
  info "Using developer cloudinit data: ${FLAGS_developer_data}"
elif [[ -s /etc/shared_user_passwd.txt ]]; then
  FLAGS_developer_data="${BUILD_DIR}/developer_data"
  info "Generating developer cloudinit with shared user password."
  cat >"${FLAGS_developer_data}" <<EOF
#cloud-config

users:
  - name: core
    passwd: $(</etc/shared_user_passwd.txt)
EOF
fi

fix_mtab

if [[ "${DEV_IMAGE}" -eq 1 ]]; then
  create_dev_image ${COREOS_DEVELOPER_IMAGE_NAME} ${DISK_LAYOUT} ${FLAGS_group} ${FLAGS_base_dev_pkg}
  if [[ ${FLAGS_extract_update} -eq ${FLAGS_TRUE} ]]; then
    extract_update "${COREOS_DEVELOPER_IMAGE_NAME}" "${DISK_LAYOUT}"
  fi
fi

if [[ "${CONTAINER}" -eq 1 ]]; then
  create_dev_image "${COREOS_DEVELOPER_CONTAINER_NAME}" "${CONTAINER_LAYOUT}" "${FLAGS_group}" ${FLAGS_base_dev_pkg}
fi

if [[ "${PROD_IMAGE}" -eq 1 ]]; then
  create_prod_image ${COREOS_PRODUCTION_IMAGE_NAME} ${DISK_LAYOUT} ${FLAGS_group} ${FLAGS_base_pkg}
  if [[ ${FLAGS_generate_update} -eq ${FLAGS_TRUE} ]]; then
    generate_update "${COREOS_PRODUCTION_IMAGE_NAME}" ${DISK_LAYOUT}
  elif [[ ${FLAGS_extract_update} -eq ${FLAGS_TRUE} ]]; then
    extract_update "${COREOS_PRODUCTION_IMAGE_NAME}" "${DISK_LAYOUT}"
  fi
fi

if [[ ${FLAGS_generate_update} -eq ${FLAGS_TRUE} ]] || \
   [[ ${FLAGS_extract_update} -eq ${FLAGS_TRUE} ]]
then
  zip_update_tools
fi

# Write out a version.txt file, this will be used by image_to_vm.sh
split_ver "${COREOS_VERSION_ID}" SPLIT
tee "${BUILD_DIR}/version.txt" <<EOF
COREOS_BUILD=${SPLIT[0]}
COREOS_BRANCH=${SPLIT[1]}
COREOS_PATCH=${SPLIT[2]}
COREOS_VERSION=${COREOS_VERSION_STRING}
COREOS_VERSION_ID=${COREOS_VERSION_ID}
COREOS_BUILD_ID="${COREOS_BUILD_ID}"
COREOS_SDK_VERSION=${COREOS_SDK_VERSION}
EOF

upload_image "${BUILD_DIR}/version.txt"

# Create a named symlink.
set_build_symlinks latest "${FLAGS_group}-latest"

echo "Done. Image(s) created in ${BUILD_DIR}"

print_image_to_vm() {
  flags=
  if [ $# = 1 ]; then
    flags="--${1}_image"
  fi

  cat << EOF
To convert it to a virtual machine image, use:
  ./image_to_vm.sh --from=${OUTSIDE_OUTPUT_DIR} --board=${BOARD} ${flags}

The default type is qemu, see ./image_to_vm.sh --help for other options.
EOF
}

# Print out the images we generated.
if [[ "${PROD_IMAGE}" -eq 1 ]]; then
  echo "CoreOS Production image created as ${COREOS_PRODUCTION_IMAGE_NAME}"
  print_image_to_vm "prod"
fi
if [[ "${DEV_IMAGE}" -eq 1 ]]; then
  echo "Developer image created as ${COREOS_DEVELOPER_IMAGE_NAME}"
  print_image_to_vm
fi

command_completed


